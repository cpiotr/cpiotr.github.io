---
ID: 205
post_title: >
  Testing JPA Entities with Guice and
  In-memory database
author: Piotr Ciruk
post_excerpt: ""
layout: post
published: true
post_date: 2014-06-02 20:33:01
---
Sometimes a need occur to perform tests that you wouldn't name neither unit tests nor integration ones. I've got such impression lately, while writing tests to cover retrieving records from the database as a JPA entities.
The subject of my test was a database query. I wanted to make sure, that records which `EntityManager` returned matched given criteria. However there was no point in calling an actual database, (unit) tests must run almost instantly.
Thus, I used an in-memory database, which was created in runtime and populated with DDL instructions generated by ORM framework.
The JPA configuration is as follows:
```
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.1" xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
	<persistence-unit name="my-persistence-unit" transaction-type="RESOURCE_LOCAL">
		<provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
		
		<class>pl.ciruk.blog.jpa_unit_tests.SampleEntity</class>
		
		<properties>
			<property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver"/>
			<property name="javax.persistence.jdbc.url" value="jdbc:derby:memory:unit-testing-jpa;create=true"/>
			<property name="javax.persistence.jdbc.user" value=""/>
			<property name="javax.persistence.jdbc.password" value=""/>
			
			<!-- Create tables at start-up -->
			<property name="hibernate.hbm2ddl.auto" value="create"/>
		</properties>
	</persistence-unit>
</persistence>
```

I used <a href="https://code.google.com/p/google-guice/" target="_blank">Google Guice</a> as a <em>Dependency Injection</em> framework and its `guice-persist` to provide `EntityManager` implementation for me.
It's turned out to be slightly onerous, because of necessity to manually start and stop `PersistenceService`.
```
package pl.ciruk.blog.jpa_unit_tests.conf;

import com.google.inject.AbstractModule;
import com.google.inject.persist.jpa.JpaPersistModule;

public class MyGuiceModule extends AbstractModule {

	@Override
	protected void configure() {
		install(new JpaPersistModule("my-persistence-unit"));
		
		bind(MyJpaInitializer.class).asEagerSingleton();
	}
}
```

```
package pl.ciruk.blog.jpa_unit_tests.conf;

import com.google.inject.Inject;
import com.google.inject.persist.PersistService;

public class MyJpaInitializer {
	private PersistService persistService;
	
	@Inject
	MyJpaInitializer(PersistService service) {
		persistService = service;
		persistService.start();
	}
	
	public void stopService() {
		persistService.stop();
	}
}
```

Finally, the test class is as follows. 
```
package pl.ciruk.blog.jpa_unit_tests;

import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.everyItem;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static pl.ciruk.blog.jpa_unit_tests.CollectionMatchers.isInCollection;
import static pl.ciruk.blog.jpa_unit_tests.SampleEntityMatchers.hasAmountLowerThan;

import java.util.List;

import javax.inject.Inject;
import javax.persistence.EntityManager;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import pl.ciruk.blog.jpa_unit_tests.conf.MyGuiceModule;
import pl.ciruk.blog.jpa_unit_tests.conf.MyJpaInitializer;

import com.google.inject.Guice;

public class SampleEntityTest {

	@Inject
	private EntityManager entityManager;
	
	@Inject
	private MyJpaInitializer jpaInitializer;
	
	@Before
	public void setUp() {
		Guice.createInjector(new MyGuiceModule()).injectMembers(this);
		entityManager.getTransaction().begin();
	}
	
	@After
	public void cleanUp() {
		entityManager.getTransaction().rollback();
		jpaInitializer.stopService();
	}
	
	@Test
	public void shouldRetrieveEntitiesWithAmountBelowThreshold() {
		int numberOfMockEntities = 100;
		List<SampleEntity> mockEntities = Entities.mockListOf(SampleEntity.class, numberOfMockEntities);
		
		double amountThreshold = 0.75;
		long numberOfEntitesWithAmountBelowThreshold = mockEntities.stream()
			.filter(entity -> entity.getAmount() < amountThreshold)
			.count();
		
		mockEntities.stream()
			.forEach(entityManager::persist);
	
		@SuppressWarnings("unchecked")
		List<SampleEntity> actualEntities = entityManager
				.createNamedQuery(SampleEntity.Query.WITH_AMOUNT_BELOW)
				.setParameter("amountThreshold", amountThreshold)
				.getResultList();
		
		assertThat(actualEntities.stream().count(), 
				is(equalTo(numberOfEntitesWithAmountBelowThreshold)));
		
		assertThat(actualEntities, 
				allOf(
					everyItem(isInCollection(mockEntities)),
					everyItem(hasAmountLowerThan(amountThreshold))
				));
	}
}

```

The complete solution can be found on <a href="https://github.com/cpiotr/blog/tree/master/blog-code/src/test/java/pl/ciruk/blog/jpa_unit_tests" target="_blank">my GitHub</a>.
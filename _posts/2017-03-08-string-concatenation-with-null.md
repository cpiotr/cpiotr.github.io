---
ID: 358
post_title: String concatenation with null
author: Piotr Ciruk
post_excerpt: ""
layout: post
permalink: >
  http://ciruk.pl/2017/03/string-concatenation-with-null/
published: true
post_date: 2017-03-08 09:03:14
---
<a href="http://ciruk.pl/2017/02/observing-class-loading-preparation-phase/">The previous post</a> concisely presented how to observe default values of static fields set during preparation phase of class loading. An integer primitive type was used as an example. Very similar behavior was described in <em>Puzzle 49: Larger Than Life</em> from <a href="https://www.amazon.com/Java-Puzzlers-Traps-Pitfalls-Corner/dp/032133678X">Java Puzzlers Traps, Pitfalls, and Corner Cases</a> by Joshua Bloch and Neal Gafter. 
When it comes to reference types, the default value is <code>null</code>, which upon dereferencing can result in a runtime exception. Let's consider the class introduced in the previous post but this time with a static field of <code>String</code> type.
[sourcecode lang="java"]
public class UnexpectedStringValue {
    static final UnexpectedStringValue instance = new UnexpectedStringValue();

    static String DEFAULT_VALUE = &quot;world&quot;;

    String member;

    public UnexpectedStringValue() {
        this.member = &quot;Hello &quot; + DEFAULT_VALUE;
    }

    public static void main(String[] args) {
        System.out.println(instance.member);
    }
}
[/sourcecode] 
During the execution on the main method from the class <code>UnexpectedStringValue</code> <code>Hello null</code> is printed to the standard output. Java compiler preemptively replaces explicit single-scope string concatenation with a chain of <code>StringBuilder.append()</code> calls. In the presented snippet javac has easy task to do, because type of DEFAULT_VALUE is known upfront. Consequently, the execution is dispatched to <code>StringBuilder.append(String)</code>. Taking a peek at generated bytecode confirms this hypothesis. Excerpt from decompiled class file corresponds to string concatenation from <code>UnexpectedStringValue</code>'s constructor.
[sourcecode lang="java"]
INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; ()V
LDC &quot;Hello &quot;
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
GETSTATIC pl/ciruk/blog/preparation/UnexpectedStringValue.DEFAULT_VALUE : Ljava/lang/String;
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
[/sourcecode]

What would compiler do if the expression from constructor was altered to append <code>null</code> directly? The following code can be compiled successfully and when executed produces the same result as the code before.
[sourcecode lang="java"]
public UnexpectedStringValue() {
    this.member = &quot;Hello &quot; + null;
}
[/sourcecode]

What did compiler actually do? This time the task was more complicated. To understand why, take a look at the following expression, which is not valid and compiler would complain with a message informing about ambiguous method reference. 
[sourcecode lang="java"]
new StringBuilder().append(null);
[/sourcecode]

Upon inspection of bytecode generated for <code>"Hello " + null</code> we can see, that yet another overloaded method was called.
[sourcecode lang="java"]
ACONST_NULL
INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/Object;)Ljava/lang/StringBuilder;
[/sourcecode]

Compiler must have applied a trick to handle <code>null</code> reference as a reference of Object type. This kind of action is dictated by JLS <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.18.1">15.18.1</a> and <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.11">5.1.11</a>, which states that during concatenation of strings, <code>null</code> references gets converted to string <code>"null"</code>.